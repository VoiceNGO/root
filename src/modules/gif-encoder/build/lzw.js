'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = compressLZW;

var _colorTable = require('./color-table');

var _colorTable2 = _interopRequireDefault(_colorTable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let LZWCompressor = class LZWCompressor {

  constructor(imageData, colorTable, colorWeightMethod, srcWidth, srcHeight, width, height, xOffset, yOffset) {
    this.codeTable = new Map();
    this.colorToIndexMap = new Map();
    this.pixelIndex = 0;
    this.output = [];

    if (xOffset + width > srcWidth || yOffset + height > srcHeight || xOffset < 0 || yOffset < 0 || width < 0 || height < 0) {
      throw new Error('Invalid dimensions passed to LZWCompressor');
    }

    Object.assign(this, {
      imageData,
      colorTable,
      colorWeightMethod,
      srcWidth,
      srcHeight,
      width,
      height,
      xOffset,
      yOffset
    });
    this.initializeCodeTable();
  }

  initializeCodeTable() {
    const { colorTable, codeTable } = this;
    const { colors } = colorTable;
    const l = colors.length;

    codeTable.clear();
    this.codeIndex = 0;

    for (let i = 0; i < l; i++) {
      const color = colors[i];
      this.addCodeToCodeTable(`${color[0]}-${color[1]}-${color[2]}`);
    }

    this.clearCode = l;
    this.EOICode = l + 1;
    this.codeIndex += 2;

    this.addOutputCode(this.clearCode);

    return this;
  }

  addCodeToCodeTable(code) {
    this.codeTable.set(code, this.codeIndex++);

    return this;
  }

  addOutputCode(code) {
    return this;
  }

  getNextColorIndex() {
    const {
      pixelIndex,
      imageData,
      colorTable,
      colorWeightMethod,
      colorToIndexMap,
      srcWidth,
      width,
      height,
      xOffset,
      yOffset
    } = this;
    this.pixelIndex++;

    const row = Math.floor(pixelIndex / width);
    const col = pixelIndex % width;
    const pixelOffset = ((row + yOffset) * srcWidth + xOffset + col) * 4;

    if (row >= height) {
      return -1;
    }

    // far faster than .slice
    const color = [
    // prettier-ignore
    imageData[pixelOffset], imageData[pixelOffset + 1], imageData[pixelOffset + 2]];

    // far faster than .join
    const colorKey = `${color[0]}-${color[1]}-${color[2]}}`;

    if (colorToIndexMap.has(colorKey)) {
      // $FlowFixMe
      return colorToIndexMap.get(colorKey);
    }

    // Scan the color table to pick out the closest color
    let bestColorIndex = -1;
    let bestColorDifference = Infinity;
    const { colors } = colorTable;
    for (let i = 0, l = colors.length; i < l; i++) {
      const colorTableColor = colors[i];
      const colorDifference = colorWeightMethod(color[0], color[1], color[2], colorTableColor[0], colorTableColor[1], colorTableColor[2]);
      if (colorDifference < bestColorDifference) {
        bestColorDifference = colorDifference;
        bestColorIndex = i;
      }
    }

    return bestColorIndex;
  }

  compress() {
    const { colorToIndexMap, codeTable } = this;

    let nextColorIndex;
    let indexBuffer = this.getNextColorIndex().toString();

    while ((nextColorIndex = this.getNextColorIndex()) >= 0) {
      indexBuffer += `-${nextColorIndex}`;
      if (colorToIndexMap.has(indexBuffer)) continue;

      this.addCodeToCodeTable(indexBuffer);
    }

    return this;
  }

  getBuffer() {
    return Buffer.from(this.output);
  }
};
function compressLZW(imageData, colorTable, colorWeightMethod, srcWidth, srcHeight, width, height, x, y) {
  const compressor = new LZWCompressor(imageData, colorTable, colorWeightMethod, srcWidth, srcHeight, width, height, x, y);

  return compressor.compress().getBuffer();
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9sencuanMiXSwibmFtZXMiOlsiY29tcHJlc3NMWlciLCJMWldDb21wcmVzc29yIiwiY29uc3RydWN0b3IiLCJpbWFnZURhdGEiLCJjb2xvclRhYmxlIiwiY29sb3JXZWlnaHRNZXRob2QiLCJzcmNXaWR0aCIsInNyY0hlaWdodCIsIndpZHRoIiwiaGVpZ2h0IiwieE9mZnNldCIsInlPZmZzZXQiLCJjb2RlVGFibGUiLCJNYXAiLCJjb2xvclRvSW5kZXhNYXAiLCJwaXhlbEluZGV4Iiwib3V0cHV0IiwiRXJyb3IiLCJPYmplY3QiLCJhc3NpZ24iLCJpbml0aWFsaXplQ29kZVRhYmxlIiwiY29sb3JzIiwibCIsImxlbmd0aCIsImNsZWFyIiwiY29kZUluZGV4IiwiaSIsImNvbG9yIiwiYWRkQ29kZVRvQ29kZVRhYmxlIiwiY2xlYXJDb2RlIiwiRU9JQ29kZSIsImFkZE91dHB1dENvZGUiLCJjb2RlIiwic2V0IiwiZ2V0TmV4dENvbG9ySW5kZXgiLCJyb3ciLCJNYXRoIiwiZmxvb3IiLCJjb2wiLCJwaXhlbE9mZnNldCIsImNvbG9yS2V5IiwiaGFzIiwiZ2V0IiwiYmVzdENvbG9ySW5kZXgiLCJiZXN0Q29sb3JEaWZmZXJlbmNlIiwiSW5maW5pdHkiLCJjb2xvclRhYmxlQ29sb3IiLCJjb2xvckRpZmZlcmVuY2UiLCJjb21wcmVzcyIsIm5leHRDb2xvckluZGV4IiwiaW5kZXhCdWZmZXIiLCJ0b1N0cmluZyIsImdldEJ1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJ4IiwieSIsImNvbXByZXNzb3IiXSwibWFwcGluZ3MiOiI7Ozs7O2tCQWtMd0JBLFc7O0FBaEx4Qjs7Ozs7O0lBS01DLGEsR0FBTixNQUFNQSxhQUFOLENBQW9COztBQW9CbEJDLGNBQ0VDLFNBREYsRUFFRUMsVUFGRixFQUdFQyxpQkFIRixFQUlFQyxRQUpGLEVBS0VDLFNBTEYsRUFNRUMsS0FORixFQU9FQyxNQVBGLEVBUUVDLE9BUkYsRUFTRUMsT0FURixFQVVFO0FBQUEsU0FqQkZD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QUFPLElBQVA7QUFDRDs7QUFFREUsY0FBb0I7QUFDbEIsV0FBT0MsT0FBT0MsSUFBUCxDQUFZLEtBQUt0QyxNQUFqQixDQUFQO0FBQ0Q7QUF4S2lCLEM7QUEyS0wsU0FBU2hCLFdBQVQsQ0FDYkcsU0FEYSxFQUViQyxVQUZhLEVBR2JDLGlCQUhhLEVBSWJDLFFBSmEsRUFLYkMsU0FMYSxFQU1iQyxLQU5hLEVBT2JDLE1BUGEsRUFRYjhDLENBUmEsRUFTYkMsQ0FUYSxFQVVMO0FBQ1IsUUFBTUMsYUFBYSxJQUFJeEQsYUFBSixDQUNqQkUsU0FEaUIsRUFFakJDLFVBRmlCLEVBR2pCQyxpQkFIaUIsRUFJakJDLFFBSmlCLEVBS2pCQyxTQUxpQixFQU1qQkMsS0FOaUIsRUFPakJDLE1BUGlCLEVBUWpCOEMsQ0FSaUIsRUFTakJDLENBVGlCLENBQW5COztBQVlBLFNBQU9DLFdBQVdULFFBQVgsR0FBc0JJLFNBQXRCLEVBQVA7QUFDRCIsImZpbGUiOiJsencuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgQ29sb3JUYWJsZSBmcm9tICcuL2NvbG9yLXRhYmxlJztcblxuaW1wb3J0IHR5cGUgeyB0Q29sb3JXZWlnaHRTaWduYXR1cmUgfSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB0eXBlIHsgdENvbG9yIH0gZnJvbSAnLi9jb2xvci10YWJsZSc7XG5cbmNsYXNzIExaV0NvbXByZXNzb3Ige1xuICBjbGVhckNvZGU6IG51bWJlcjtcbiAgRU9JQ29kZTogbnVtYmVyO1xuICBpbWFnZURhdGE6IEFycmF5PG51bWJlcj47XG4gIGNvbG9yVGFibGU6IENvbG9yVGFibGU7XG4gIHNyY1dpZHRoOiBudW1iZXI7XG4gIHNyY0hlaWdodDogbnVtYmVyO1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgeE9mZnNldDogbnVtYmVyO1xuICB5T2Zmc2V0OiBudW1iZXI7XG4gIGNvbG9yV2VpZ2h0TWV0aG9kOiB0Q29sb3JXZWlnaHRTaWduYXR1cmU7XG5cbiAgY29kZVRhYmxlOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuICBjb2xvclRvSW5kZXhNYXA6IE1hcDxzdHJpbmcsIG51bWJlcj4gPSBuZXcgTWFwKCk7XG4gIGNvZGVJbmRleDogbnVtYmVyO1xuICBwaXhlbEluZGV4OiBudW1iZXIgPSAwO1xuXG4gIG91dHB1dDogQXJyYXk8bnVtYmVyPiA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGltYWdlRGF0YTogQXJyYXk8bnVtYmVyPixcbiAgICBjb2xvclRhYmxlOiBDb2xvclRhYmxlLFxuICAgIGNvbG9yV2VpZ2h0TWV0aG9kOiB0Q29sb3JXZWlnaHRTaWduYXR1cmUsXG4gICAgc3JjV2lkdGg6IG51bWJlcixcbiAgICBzcmNIZWlnaHQ6IG51bWJlcixcbiAgICB3aWR0aDogbnVtYmVyLFxuICAgIGhlaWdodDogbnVtYmVyLFxuICAgIHhPZmZzZXQ6IG51bWJlcixcbiAgICB5T2Zmc2V0OiBudW1iZXIsXG4gICkge1xuICAgIGlmIChcbiAgICAgIHhPZmZzZXQgKyB3aWR0aCA+IHNyY1dpZHRoIHx8XG4gICAgICB5T2Zmc2V0ICsgaGVpZ2h0ID4gc3JjSGVpZ2h0IHx8XG4gICAgICB4T2Zmc2V0IDwgMCB8fFxuICAgICAgeU9mZnNldCA8IDAgfHxcbiAgICAgIHdpZHRoIDwgMCB8fFxuICAgICAgaGVpZ2h0IDwgMFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpbWVuc2lvbnMgcGFzc2VkIHRvIExaV0NvbXByZXNzb3InKTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgIGltYWdlRGF0YSxcbiAgICAgIGNvbG9yVGFibGUsXG4gICAgICBjb2xvcldlaWdodE1ldGhvZCxcbiAgICAgIHNyY1dpZHRoLFxuICAgICAgc3JjSGVpZ2h0LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB4T2Zmc2V0LFxuICAgICAgeU9mZnNldCxcbiAgICB9KTtcbiAgICB0aGlzLmluaXRpYWxpemVDb2RlVGFibGUoKTtcbiAgfVxuXG4gIGluaXRpYWxpemVDb2RlVGFibGUoKTogdGhpcyB7XG4gICAgY29uc3QgeyBjb2xvclRhYmxlLCBjb2RlVGFibGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBjb2xvcnMgfSA9IGNvbG9yVGFibGU7XG4gICAgY29uc3QgbCA9IGNvbG9ycy5sZW5ndGg7XG5cbiAgICBjb2RlVGFibGUuY2xlYXIoKTtcbiAgICB0aGlzLmNvZGVJbmRleCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgY29sb3IgPSBjb2xvcnNbaV07XG4gICAgICB0aGlzLmFkZENvZGVUb0NvZGVUYWJsZShgJHtjb2xvclswXX0tJHtjb2xvclsxXX0tJHtjb2xvclsyXX1gKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyQ29kZSA9IGw7XG4gICAgdGhpcy5FT0lDb2RlID0gbCArIDE7XG4gICAgdGhpcy5jb2RlSW5kZXggKz0gMjtcblxuICAgIHRoaXMuYWRkT3V0cHV0Q29kZSh0aGlzLmNsZWFyQ29kZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZENvZGVUb0NvZGVUYWJsZShjb2RlOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB0aGlzLmNvZGVUYWJsZS5zZXQoY29kZSwgdGhpcy5jb2RlSW5kZXgrKyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZE91dHB1dENvZGUoY29kZTogbnVtYmVyKTogdGhpcyB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXROZXh0Q29sb3JJbmRleCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHtcbiAgICAgIHBpeGVsSW5kZXgsXG4gICAgICBpbWFnZURhdGEsXG4gICAgICBjb2xvclRhYmxlLFxuICAgICAgY29sb3JXZWlnaHRNZXRob2QsXG4gICAgICBjb2xvclRvSW5kZXhNYXAsXG4gICAgICBzcmNXaWR0aCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgeE9mZnNldCxcbiAgICAgIHlPZmZzZXQsXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5waXhlbEluZGV4Kys7XG5cbiAgICBjb25zdCByb3cgPSBNYXRoLmZsb29yKHBpeGVsSW5kZXggLyB3aWR0aCk7XG4gICAgY29uc3QgY29sID0gcGl4ZWxJbmRleCAlIHdpZHRoO1xuICAgIGNvbnN0IHBpeGVsT2Zmc2V0ID0gKChyb3cgKyB5T2Zmc2V0KSAqIHNyY1dpZHRoICsgeE9mZnNldCArIGNvbCkgKiA0O1xuXG4gICAgaWYgKHJvdyA+PSBoZWlnaHQpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBmYXIgZmFzdGVyIHRoYW4gLnNsaWNlXG4gICAgY29uc3QgY29sb3IgPSBbXG4gICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgIGltYWdlRGF0YVtwaXhlbE9mZnNldF0sXG4gICAgICBpbWFnZURhdGFbcGl4ZWxPZmZzZXQgKyAxXSxcbiAgICAgIGltYWdlRGF0YVtwaXhlbE9mZnNldCArIDJdLFxuICAgIF07XG5cbiAgICAvLyBmYXIgZmFzdGVyIHRoYW4gLmpvaW5cbiAgICBjb25zdCBjb2xvcktleSA9IGAke2NvbG9yWzBdfS0ke2NvbG9yWzFdfS0ke2NvbG9yWzJdfX1gO1xuXG4gICAgaWYgKGNvbG9yVG9JbmRleE1hcC5oYXMoY29sb3JLZXkpKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICByZXR1cm4gY29sb3JUb0luZGV4TWFwLmdldChjb2xvcktleSk7XG4gICAgfVxuXG4gICAgLy8gU2NhbiB0aGUgY29sb3IgdGFibGUgdG8gcGljayBvdXQgdGhlIGNsb3Nlc3QgY29sb3JcbiAgICBsZXQgYmVzdENvbG9ySW5kZXggPSAtMTtcbiAgICBsZXQgYmVzdENvbG9yRGlmZmVyZW5jZSA9IEluZmluaXR5O1xuICAgIGNvbnN0IHsgY29sb3JzIH0gPSBjb2xvclRhYmxlO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gY29sb3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgY29sb3JUYWJsZUNvbG9yID0gY29sb3JzW2ldO1xuICAgICAgY29uc3QgY29sb3JEaWZmZXJlbmNlID0gY29sb3JXZWlnaHRNZXRob2QoXG4gICAgICAgIGNvbG9yWzBdLFxuICAgICAgICBjb2xvclsxXSxcbiAgICAgICAgY29sb3JbMl0sXG4gICAgICAgIGNvbG9yVGFibGVDb2xvclswXSxcbiAgICAgICAgY29sb3JUYWJsZUNvbG9yWzFdLFxuICAgICAgICBjb2xvclRhYmxlQ29sb3JbMl0sXG4gICAgICApO1xuICAgICAgaWYgKGNvbG9yRGlmZmVyZW5jZSA8IGJlc3RDb2xvckRpZmZlcmVuY2UpIHtcbiAgICAgICAgYmVzdENvbG9yRGlmZmVyZW5jZSA9IGNvbG9yRGlmZmVyZW5jZTtcbiAgICAgICAgYmVzdENvbG9ySW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiZXN0Q29sb3JJbmRleDtcbiAgfVxuXG4gIGNvbXByZXNzKCk6IHRoaXMge1xuICAgIGNvbnN0IHsgY29sb3JUb0luZGV4TWFwLCBjb2RlVGFibGUgfSA9IHRoaXM7XG5cbiAgICBsZXQgbmV4dENvbG9ySW5kZXg7XG4gICAgbGV0IGluZGV4QnVmZmVyID0gdGhpcy5nZXROZXh0Q29sb3JJbmRleCgpLnRvU3RyaW5nKCk7XG5cbiAgICB3aGlsZSAoKG5leHRDb2xvckluZGV4ID0gdGhpcy5nZXROZXh0Q29sb3JJbmRleCgpKSA+PSAwKSB7XG4gICAgICBpbmRleEJ1ZmZlciArPSBgLSR7bmV4dENvbG9ySW5kZXh9YDtcbiAgICAgIGlmIChjb2xvclRvSW5kZXhNYXAuaGFzKGluZGV4QnVmZmVyKSkgY29udGludWU7XG5cbiAgICAgIHRoaXMuYWRkQ29kZVRvQ29kZVRhYmxlKGluZGV4QnVmZmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldEJ1ZmZlcigpOiBCdWZmZXIge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLm91dHB1dCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHJlc3NMWlcoXG4gIGltYWdlRGF0YTogQXJyYXk8bnVtYmVyPixcbiAgY29sb3JUYWJsZTogQ29sb3JUYWJsZSxcbiAgY29sb3JXZWlnaHRNZXRob2Q6IHRDb2xvcldlaWdodFNpZ25hdHVyZSxcbiAgc3JjV2lkdGg6IG51bWJlcixcbiAgc3JjSGVpZ2h0OiBudW1iZXIsXG4gIHdpZHRoOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbik6IEJ1ZmZlciB7XG4gIGNvbnN0IGNvbXByZXNzb3IgPSBuZXcgTFpXQ29tcHJlc3NvcihcbiAgICBpbWFnZURhdGEsXG4gICAgY29sb3JUYWJsZSxcbiAgICBjb2xvcldlaWdodE1ldGhvZCxcbiAgICBzcmNXaWR0aCxcbiAgICBzcmNIZWlnaHQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeSxcbiAgKTtcblxuICByZXR1cm4gY29tcHJlc3Nvci5jb21wcmVzcygpLmdldEJ1ZmZlcigpO1xufVxuIl19